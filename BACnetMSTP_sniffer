// BACnet MS/TP Passive Scanner (ESP32)
// Hardware: ESP32 + 3.3V RS-485 transceiver (e.g., MAX3485)
// Bus on Serial2 (UART2) so Serial(USB) is free for logs.
// Keep RE/DE LOW for receive-only.

#include <Arduino.h>

// ---------- User settings ----------
#define BAUD              38400UL   // Set to your MS/TP baud: 9600/19200/38400/76800, etc.
#define BUS_UART_RX_PIN   16        // RO -> ESP32 RX2
#define BUS_UART_TX_PIN   17        // DI -> ESP32 TX2 (unused but must be valid)
#define REDE_PIN          4         // RE+DE tied together; LOW = receive
#define REPORT_MS         3000
#define FRAME_TIMEOUT_MS  100
#define MAX_PAYLOAD       501

// Choose which serial is the bus and which is console
HardwareSerial& BUS = Serial2;      // MS/TP bus (UART2)
HardwareSerial& CON = Serial;       // USB console

// MS/TP constants
const uint8_t PREAMBLE0 = 0x55;
const uint8_t PREAMBLE1 = 0xFF;

// (Subset) Frame types for printouts
const uint8_t FRAME_TOKEN                = 0x00;
const uint8_t FRAME_POLL_FOR_MASTER      = 0x01;
const uint8_t FRAME_REPLY_TO_PFM         = 0x02;
const uint8_t FRAME_TEST_REQUEST         = 0x03;
const uint8_t FRAME_TEST_RESPONSE        = 0x04;
const uint8_t FRAME_DATA_EXPECTING_REPLY = 0x05;
const uint8_t FRAME_DATA_NO_REPLY        = 0x06;
const uint8_t FRAME_REPLY_POSTPONED      = 0x07;

// Stats
volatile uint32_t stat_bad_preamble = 0;
volatile uint32_t stat_hdr_crc_fail = 0;
volatile uint32_t stat_data_crc_fail= 0;
volatile uint32_t stat_len_error    = 0;
volatile uint32_t stat_timeouts     = 0;
volatile uint32_t stat_frames_ok    = 0;

// Discovered MACs 0..127
bool mac_seen[128] = {false};

// ---------- CRCs per BACnet MS/TP ----------
// Header CRC-8: poly 0x31, init 0xFF, final ones-complement
uint8_t mstp_crc8(const uint8_t* data, size_t len) {
  uint8_t crc = 0xFF;
  for (size_t i = 0; i < len; i++) {
    crc ^= data[i];
    for (uint8_t b = 0; b < 8; b++) {
      crc = (crc & 0x80) ? (uint8_t)((crc << 1) ^ 0x31) : (uint8_t)(crc << 1);
    }
  }
  return (uint8_t)~crc;
}

// Data CRC-16 (ANSI/IBM): poly 0xA001 (reflected), init 0xFFFF, final ones-complement
uint16_t mstp_crc16(const uint8_t* data, size_t len) {
  uint16_t crc = 0xFFFF;
  for (size_t i = 0; i < len; i++) {
    crc ^= data[i];
    for (uint8_t b = 0; b < 8; b++) {
      if (crc & 0x0001) crc = (crc >> 1) ^ 0xA001;
      else              crc >>= 1;
    }
  }
  return (uint16_t)~crc;
}

// Read exactly n bytes from BUS with timeout
size_t busReadBytesTimeout(uint8_t* buf, size_t n, uint32_t timeout_ms) {
  uint32_t start = millis();
  size_t got = 0;
  while (got < n) {
    while (BUS.available()) {
      buf[got++] = (uint8_t)BUS.read();
      if (got >= n) return got;
    }
    if (millis() - start > timeout_ms) break;
    // yield to keep WiFi/RTOS happy even if not used
    delay(0);
  }
  return got;
}

void printFrameType(uint8_t t) {
  switch (t) {
    case FRAME_TOKEN:                 CON.print(F("TOKEN")); break;
    case FRAME_POLL_FOR_MASTER:       CON.print(F("PFM")); break;
    case FRAME_REPLY_TO_PFM:          CON.print(F("REPLY_TO_PFM")); break;
    case FRAME_TEST_REQUEST:          CON.print(F("TEST_REQ")); break;
    case FRAME_TEST_RESPONSE:         CON.print(F("TEST_RESP")); break;
    case FRAME_DATA_EXPECTING_REPLY:  CON.print(F("DATA+REPLY")); break;
    case FRAME_DATA_NO_REPLY:         CON.print(F("DATA")); break;
    case FRAME_REPLY_POSTPONED:       CON.print(F("REPLY_POSTPONED")); break;
    default:                          CON.print(F("TYPE_0x")); CON.print(t, HEX); break;
  }
}

void setup() {
  pinMode(REDE_PIN, OUTPUT);
  digitalWrite(REDE_PIN, LOW);          // listen-only

  // Console
  CON.begin(115200);
  delay(200);

  // MS/TP bus on UART2 (8N1), set RX/TX pins explicitly
  BUS.begin(BAUD, SERIAL_8N1, BUS_UART_RX_PIN, BUS_UART_TX_PIN);
  // Optional: enlarge RX FIFO a bit (ESP32 default is decent)
  BUS.setRxBufferSize(2048);

  CON.println(F("\nBACnet MS/TP Passive Scanner (ESP32, listen-only)"));
  CON.print(F("Bus baud: ")); CON.println(BAUD);
  CON.print(F("Bus RX pin: ")); CON.println(BUS_UART_RX_PIN);
  CON.println(F("Listening for frames..."));
}

void loop() {
  static uint32_t last_report = 0;

  // Sync to preamble 0x55 0xFF
  if (BUS.available() >= 2) {
    int b0 = BUS.read();
    if (b0 == PREAMBLE0) {
      int b1 = -1;
      uint32_t t0 = millis();
      while (!BUS.available() && (millis() - t0) < FRAME_TIMEOUT_MS) { delay(0); }
      if (BUS.available()) b1 = BUS.read();

      if (b1 == PREAMBLE1) {
        // Read fixed header (5 bytes): frameType, dest, src, lenL, lenH
        uint8_t hdr[5];
        size_t got = busReadBytesTimeout(hdr, 5, FRAME_TIMEOUT_MS);
        if (got != 5) { stat_timeouts++; goto REPORT_MAYBE; }

        // Read header CRC (1 byte)
        uint8_t hdr_crc_rx = 0;
        got = busReadBytesTimeout(&hdr_crc_rx, 1, FRAME_TIMEOUT_MS);
        if (got != 1) { stat_timeouts++; goto REPORT_MAYBE; }

        // Validate header CRC
        uint8_t hdr_crc_calc = mstp_crc8(hdr, 5);
        if (hdr_crc_calc != hdr_crc_rx) {
          stat_hdr_crc_fail++;
          goto REPORT_MAYBE;
        }

        uint8_t frame_type = hdr[0];
        uint8_t dest       = hdr[1];
        uint8_t src        = hdr[2];
        uint16_t len       = (uint16_t)hdr[3] | ((uint16_t)hdr[4] << 8);

        if (len > MAX_PAYLOAD) {
          stat_len_error++;
          // Drain expected payload+CRC to re-sync
          for (uint32_t i = 0; i < (uint32_t)len + 2; i++) {
            uint32_t t1 = millis();
            while (!BUS.available() && (millis() - t1) < FRAME_TIMEOUT_MS) { delay(0); }
            if (BUS.available()) BUS.read(); else { stat_timeouts++; break; }
          }
          goto REPORT_MAYBE;
        }

        // Read payload and data CRC
        static uint8_t payload[MAX_PAYLOAD];
        if (len > 0) {
          got = busReadBytesTimeout(payload, len, FRAME_TIMEOUT_MS);
          if (got != len) { stat_timeouts++; goto REPORT_MAYBE; }
        }
        uint8_t crc16_lohi[2];
        got = busReadBytesTimeout(crc16_lohi, 2, FRAME_TIMEOUT_MS);
        if (got != 2) { stat_timeouts++; goto REPORT_MAYBE; }

        uint16_t crc16_rx = (uint16_t)crc16_lohi[0] | ((uint16_t)crc16_lohi[1] << 8);
        uint16_t crc16_calc = mstp_crc16(payload, len);
        if (crc16_calc != crc16_rx) {
          stat_data_crc_fail++;
          goto REPORT_MAYBE;
        }

        // Valid frame
        stat_frames_ok++;
        if (src < 128) mac_seen[src] = true;

        // Optional per-frame line
        CON.print(F("[OK] ")); printFrameType(frame_type);
        CON.print(F("  src=")); CON.print(src);
        CON.print(F("  dst=")); CON.print(dest);
        CON.print(F("  len=")); CON.println(len);

      } else {
        stat_bad_preamble++;
      }
    }
  }

REPORT_MAYBE:
  if (millis() - last_report >= REPORT_MS) {
    last_report = millis();

    CON.println(F("\n----- BACnet MS/TP Scan Report -----"));
    CON.print(F("MACs seen: "));
    bool first = true;
    for (uint8_t i = 0; i < 128; i++) {
      if (mac_seen[i]) {
        if (!first) CON.print(F(", "));
        CON.print(i);
        first = false;
      }
    }
    if (first) CON.print(F("(none yet)"));
    CON.println();

    CON.print(F("Frames OK: "));        CON.println(stat_frames_ok);
    CON.print(F("Bad preamble: "));     CON.println(stat_bad_preamble);
    CON.print(F("Header CRC fails: ")); CON.println(stat_hdr_crc_fail);
    CON.print(F("Data CRC fails: "));   CON.println(stat_data_crc_fail);
    CON.print(F("Len/Buffer errors: "));CON.println(stat_len_error);
    CON.print(F("Timeouts: "));         CON.println(stat_timeouts);
    CON.println(F("------------------------------------"));
  }
}
