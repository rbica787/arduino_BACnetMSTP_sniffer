// Waveshare ESP32-C6 1.47" Display Dev Board (ST7789 172x320)
// BACnet MS/TP Passive Scanner + On-screen MAC map (0..127)
// - Green circle = seen recently (online)
// - Grey circle  = was seen before but quiet for OFFLINE_MS
// - No circle    = never seen yet
//
// Requires: Adafruit GFX, Adafruit ST7735 and ST7789 Library

#include <Arduino.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ST7789.h>
#include <SPI.h>

// ---------------- USER OPTIONS ----------------
#define BAUD                38400UL   // MS/TP baud (9600/19200/38400/76800 etc.)
#define REPORT_MS           1000      // Update footer & aging check every 1s
#define FRAME_TIMEOUT_MS    100       // Inter-byte timeout while parsing frames
#define MAX_PAYLOAD         501       // MS/TP payload max per spec
#define OFFLINE_MS          10000UL   // If not seen in this many ms -> "grey/offline"

// UART pins (ESP32-C6 can remap UART pins freely)
#define BUS_UART_RX_PIN     16        // RS-485 RO -> here
#define BUS_UART_TX_PIN     17        // RS-485 DI -> here (unused but must be valid)
#define REDE_PIN            4         // RS-485 RE/DE tied; keep LOW for receive-only

HardwareSerial& BUS = Serial1;        // MS/TP bus
HardwareSerial& CON = Serial;         // USB serial for logs

// -------- DISPLAY PINS / OPTIONS (edit if your board differs) --------
#define TFT_CS   5
#define TFT_DC   6
#define TFT_RST  7
#define TFT_SCLK 8
#define TFT_MOSI 10
#define TFT_ROTATION 1   // 0/1/2/3

// Custom colors (RGB565)
#define COLOR_GREY   0x8410   // mid grey
#define COLOR_GRID   0x4208   // dark grey

Adafruit_ST7789 tft = Adafruit_ST7789(TFT_CS, TFT_DC, TFT_RST);

// ---------------- BACnet MS/TP bits ----------------
const uint8_t PREAMBLE0 = 0x55;
const uint8_t PREAMBLE1 = 0xFF;

const uint8_t FRAME_TOKEN                 = 0x00;
const uint8_t FRAME_POLL_FOR_MASTER       = 0x01;
const uint8_t FRAME_REPLY_TO_PFM          = 0x02;
const uint8_t FRAME_TEST_REQUEST          = 0x03;
const uint8_t FRAME_TEST_RESPONSE         = 0x04;
const uint8_t FRAME_DATA_EXPECTING_REPLY  = 0x05;
const uint8_t FRAME_DATA_NO_REPLY         = 0x06;
const uint8_t FRAME_REPLY_POSTPONED       = 0x07;

// Stats
volatile uint32_t stat_bad_preamble = 0;
volatile uint32_t stat_hdr_crc_fail = 0;
volatile uint32_t stat_data_crc_fail= 0;
volatile uint32_t stat_len_error    = 0;
volatile uint32_t stat_timeouts     = 0;
volatile uint32_t stat_frames_ok    = 0;

// Presence tracking for 0..127
bool     ever_seen[128]     = {false};   // was ever observed at least once
bool     online_now[128]    = {false};   // currently "online" (fresh within OFFLINE_MS)
uint32_t last_seen_ms[128]  = {0};       // millis() timestamp of last good frame from addr

// ---------- CRC helpers ----------
uint8_t mstp_crc8(const uint8_t* data, size_t len) {
  uint8_t crc = 0xFF;
  for (size_t i = 0; i < len; i++) {
    crc ^= data[i];
    for (uint8_t b = 0; b < 8; b++) {
      crc = (crc & 0x80) ? (uint8_t)((crc << 1) ^ 0x31) : (uint8_t)(crc << 1);
    }
  }
  return (uint8_t)~crc;
}

uint16_t mstp_crc16(const uint8_t* data, size_t len) {
  uint16_t crc = 0xFFFF;
  for (size_t i = 0; i < len; i++) {
    crc ^= data[i];
    for (uint8_t b = 0; b < 8; b++) {
      if (crc & 0x0001) crc = (crc >> 1) ^ 0xA001;
      else              crc >>= 1;
    }
  }
  return (uint16_t)~crc;
}

size_t busReadBytesTimeout(uint8_t* buf, size_t n, uint32_t timeout_ms) {
  uint32_t start = millis();
  size_t got = 0;
  while (got < n) {
    while (BUS.available()) {
      buf[got++] = (uint8_t)BUS.read();
      if (got >= n) return got;
    }
    if (millis() - start > timeout_ms) break;
    delay(0);
  }
  return got;
}

// ---------- Grid layout ----------
struct Cell {
  int16_t x, y, w, h;
  int16_t cx, cy;
};
static const uint8_t COLS = 8;   // 8 x 16 = 128 slots (0..127)
static const uint8_t ROWS = 16;
Cell cells[128];                 // indexed by addr 0..127

int16_t SCREEN_W = 172;
int16_t SCREEN_H = 320;
int16_t ERR_BAR_H = 60;
int16_t GRID_H;
int16_t CELL_W, CELL_H;

void layoutGrid() {
  SCREEN_W = tft.width();
  SCREEN_H = tft.height();
  GRID_H   = SCREEN_H - ERR_BAR_H;

  CELL_W = SCREEN_W / COLS;
  CELL_H = GRID_H   / ROWS;

  for (uint8_t addr = 0; addr <= 127; addr++) {
    uint8_t row = addr / COLS;
    uint8_t col = addr % COLS;
    Cell &c = cells[addr];
    c.x  = col * CELL_W;
    c.y  = row * CELL_H;
    c.w  = CELL_W;
    c.h  = CELL_H;
    c.cx = c.x + c.w / 2;
    c.cy = c.y + c.h / 2;
  }
}

void drawCellBase(uint8_t addr) {
  const Cell &c = cells[addr];
  // cell border
  tft.drawRect(c.x, c.y, c.w, c.h, COLOR_GRID);

  // number centered
  char buf[5];
  snprintf(buf, sizeof(buf), "%u", addr);
  int16_t bx, by; uint16_t bw, bh;
  tft.getTextBounds(buf, 0, 0, &bx, &by, &bw, &bh);
  int16_t tx = c.cx - (int)bw/2;
  int16_t ty = c.cy - (int)bh/2;

  tft.setTextColor(ST77XX_WHITE);
  tft.setCursor(tx, ty);
  tft.print(buf);
}

void drawGridNumbers() {
  tft.fillScreen(ST77XX_BLACK);
  tft.setTextSize(1);
  for (uint8_t addr = 0; addr <= 127; addr++) {
    drawCellBase(addr);
  }
  // footer separator
  tft.drawFastHLine(0, GRID_H, SCREEN_W, ST77XX_WHITE);
}

void drawCircleFor(uint8_t addr, uint16_t color) {
  const Cell &c = cells[addr];
  int16_t r = min(c.w, c.h) / 2 - 3;
  if (r < 4) r = 4;
  tft.drawCircle(c.cx, c.cy, r, color);
  tft.drawCircle(c.cx, c.cy, r-1, color);
}

void redrawCell(uint8_t addr) {
  // Clear cell area then re-draw number + circle state
  const Cell &c = cells[addr];
  tft.fillRect(c.x+1, c.y+1, c.w-2, c.h-2, ST77XX_BLACK); // inside clear, keep border
  drawCellBase(addr);

  if (ever_seen[addr]) {
    if (online_now[addr]) drawCircleFor(addr, ST77XX_GREEN);
    else                  drawCircleFor(addr, COLOR_GREY);
  }
}

void clearFooter() {
  tft.fillRect(0, GRID_H + 1, SCREEN_W, ERR_BAR_H - 1, ST77XX_BLACK);
}

void drawFooterStats() {
  clearFooter();
  tft.setTextColor(ST77XX_YELLOW);
  tft.setTextSize(1);
  int16_t x = 2, y = GRID_H + 6;
  auto line = [&](const char* label, uint32_t v) {
    tft.setCursor(x, y);
    tft.print(label); tft.print(": "); tft.print(v);
    y += 12;
  };
  line("OK",        stat_frames_ok);
  line("BadPre",    stat_bad_preamble);
  line("HdrCRC",    stat_hdr_crc_fail);
  line("DataCRC",   stat_data_crc_fail);
  line("LenErr",    stat_len_error);
  line("Timeout",   stat_timeouts);
}

// ---------- Logs (optional) ----------
void printFrameType(uint8_t t) {
  switch (t) {
    case FRAME_TOKEN:                 CON.print(F("TOKEN")); break;
    case FRAME_POLL_FOR_MASTER:       CON.print(F("PFM")); break;
    case FRAME_REPLY_TO_PFM:          CON.print(F("REPLY_TO_PFM")); break;
    case FRAME_TEST_REQUEST:          CON.print(F("TEST_REQ")); break;
    case FRAME_TEST_RESPONSE:         CON.print(F("TEST_RESP")); break;
    case FRAME_DATA_EXPECTING_REPLY:  CON.print(F("DATA+REPLY")); break;
    case FRAME_DATA_NO_REPLY:         CON.print(F("DATA")); break;
    case FRAME_REPLY_POSTPONED:       CON.print(F("REPLY_POSTPONED")); break;
    default:                          CON.print(F("TYPE_0x")); CON.print(t, HEX); break;
  }
}

// ---------- Setup / Loop ----------
void setup() {
  pinMode(REDE_PIN, OUTPUT);
  digitalWrite(REDE_PIN, LOW);   // listen-only

  CON.begin(115200);
  delay(200);

  BUS.begin(BAUD, SERIAL_8N1, BUS_UART_RX_PIN, BUS_UART_TX_PIN);
  BUS.setRxBufferSize(2048);

  SPI.begin(TFT_SCLK, /*MISO*/ -1, TFT_MOSI, TFT_CS);
  tft.init(172, 320);            // ST7789 1.47" panel
  tft.setRotation(TFT_ROTATION);

  layoutGrid();
  drawGridNumbers();
  drawFooterStats();

  CON.println(F("\nBACnet MS/TP Passive Scanner + Display (ESP32-C6)"));
  CON.print(F("Bus baud: ")); CON.println(BAUD);
  CON.println(F("Listening..."));
}

void loop() {
  static uint32_t last_report = 0;

  // Frame sync on preamble 0x55 0xFF
  if (BUS.available() >= 2) {
    int b0 = BUS.read();
    if (b0 == PREAMBLE0) {
      int b1 = -1;
      uint32_t t0 = millis();
      while (!BUS.available() && (millis() - t0) < FRAME_TIMEOUT_MS) { delay(0); }
      if (BUS.available()) b1 = BUS.read();

      if (b1 == PREAMBLE1) {
        // header bytes: type, dest, src, lenL, lenH
        uint8_t hdr[5];
        size_t got = busReadBytesTimeout(hdr, 5, FRAME_TIMEOUT_MS);
        if (got != 5) { stat_timeouts++; goto PERIODIC; }

        uint8_t hdr_crc_rx = 0;
        got = busReadBytesTimeout(&hdr_crc_rx, 1, FRAME_TIMEOUT_MS);
        if (got != 1) { stat_timeouts++; goto PERIODIC; }

        uint8_t hdr_crc_calc = mstp_crc8(hdr, 5);
        if (hdr_crc_calc != hdr_crc_rx) { stat_hdr_crc_fail++; goto PERIODIC; }

        uint8_t frame_type = hdr[0];
        // uint8_t dest     = hdr[1];
        uint8_t src        = hdr[2];
        uint16_t len       = (uint16_t)hdr[3] | ((uint16_t)hdr[4] << 8);

        if (len > MAX_PAYLOAD) {
          stat_len_error++;
          // drain payload + CRC to re-sync
          for (uint32_t i = 0; i < (uint32_t)len + 2; i++) {
            uint32_t t1 = millis();
            while (!BUS.available() && (millis() - t1) < FRAME_TIMEOUT_MS) { delay(0); }
            if (BUS.available()) BUS.read(); else { stat_timeouts++; break; }
          }
          goto PERIODIC;
        }

        static uint8_t payload[MAX_PAYLOAD];
        if (len > 0) {
          got = busReadBytesTimeout(payload, len, FRAME_TIMEOUT_MS);
          if (got != len) { stat_timeouts++; goto PERIODIC; }
        }
        uint8_t crc16_lohi[2];
        got = busReadBytesTimeout(crc16_lohi, 2, FRAME_TIMEOUT_MS);
        if (got != 2) { stat_timeouts++; goto PERIODIC; }

        uint16_t crc16_rx = (uint16_t)crc16_lohi[0] | ((uint16_t)crc16_lohi[1] << 8);
        uint16_t crc16_calc = mstp_crc16(payload, len);
        if (crc16_calc != crc16_rx) { stat_data_crc_fail++; goto PERIODIC; }

        // Valid frame from src
        stat_frames_ok++;
        if (src <= 127) {
          bool was_online = online_now[src];
          ever_seen[src] = true;
          online_now[src] = true;
          last_seen_ms[src] = millis();

          if (!was_online) {
            // came online: redraw as green
            redrawCell(src);
          }
        }

        // (optional) log minimal info
        // CON.print(F("[OK] ")); printFrameType(frame_type);
        // CON.print(F(" src=")); CON.println(src);

      } else {
        stat_bad_preamble++;
      }
    }
  }

PERIODIC:
  if (millis() - last_report >= REPORT_MS) {
    last_report = millis();

    // Aging: flip any stale-online entries to grey/offline
    uint32_t now = millis();
    for (uint8_t addr = 0; addr <= 127; addr++) {
      if (online_now[addr] && (now - last_seen_ms[addr] > OFFLINE_MS)) {
        online_now[addr] = false;   // transitioned to offline
        if (ever_seen[addr]) redrawCell(addr); // repaint to grey
      }
    }

    drawFooterStats();
  }
}
